# MixTape

## Problem Description
This is a program which reads user, playlist, and songs data from source json;  
Modifies the existing data in memory, and  
write a new output file with the modifications in the same format of the source json.  

## To Run:
1. MixTape.jar is located under https://github.com/renish-shah/MixTape  
2. Go to "MixTape" dir where you can see resources dir as well Or just create "resources" directory in your current directory  
3. Usage: java -jar MixTape.jar src-json-file changes-json-file output-json-file  
All required param files should be under MixTape/resources/*  
Basically, current dir from where you are running the jar, you should have "resources" dir  
- src-json-file    : mixtape-data.json  
- changes-json-file: mixtape-changes.json (also, this file is self explanatory)  
- output-json-file : mixtape-output.json - you might have to format the json file after it is created depending on editor or you can just copy-paste file to jsonlint.com and validate.  

4. Run using: "java -jar ../mixTape.jar mixtape-data.json mixtape-changes.json output.json"  
Output:  
Parsing Src file: resources/mixtape-data.json  
Parsing Changes file: resources/mixtape-changes.json  
Writing output file: resources/output.json  

## Current Approach vs. Scale Approach

### 1. Current Approach: 
- Open and Read input file in memory, and fill up maps  
- Read Changes file and modify the existing maps  : imp -change- generating userId randomly
- Write to output file  
- Note: HashMaps are used as a Data Structure to access data faster in o(1) while modifying the data using changes file.  
- Map<String, Playlist> idToPlayListMap  
- Map<String, Song> songIdToDetailMap  
- Map<String, User> userIdToDetailsMap

- Changes File Approach:  
Changes file has one functionality to add new playList, and in real world, any id which is for the object/entity would not be sequential.  
Also, whenever we create a new entity, Id should be generated by the system and not provided by the User.  
Therefore, I have used UUID to generate new Id for the newly added PlayList instead of User providing the id.  

### 2. Scale Approach:

2.1.1 Parse users, songs and playlist in parallel for the large input file  
Let's assume, the src input file has 1m entries of users, then we can divide these Users into equal chunks and process using multi-threading / parallel  
Above approach will apply to large changes file as well  

2.2.1 Caveat with Changes file is: we need to identify dependency / ordering between add playlist, and remove playlist to avoid miss-expectation of users.  

2.3.1 If the file is too large to open in memory, will have to read the file in streaming fashion in chunks, store the current index (to be utilized to start from the stored index for reading again), and batch the data while parsing chunks.  

2.3.2 One other way is to divide the input files into different files:  
For eg.: instead of having one src file including users, songs, and playlist => we can have 3 different src files to process; and similar can be applied to changes file as well.